package com.example.customview

import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Rect
import android.text.Layout
import android.text.StaticLayout
import android.text.TextPaint
import android.util.AttributeSet
import android.view.View

class ExpandableTextView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0,
    defStyleRes: Int = 0
) : View(context, attrs, defStyleAttr, defStyleRes) {
    private var isSingleLine = false
    private var isExpanding = false
    var text = ""
        set(value) {
            if (value == field) return
            field = value
            isNeedCalculated = true
            invalidate()
        }
    val textPaint = TextPaint().apply {
        textSize = 20.sp
        color = Color.BLACK
    }
    var textSize = 0
        set(value) {
            if (value == field || value < 0) return
            field = value
            textPaint.textSize = value.sp
            ellipsizeTextWidth = getTextWidth(ellipsizedText)
            isNeedCalculated = true
            invalidate()
        }
    var contentHeight = 0
    var ellipsizedText = "...See more"
        set(value) {
            if (value == field || value.isBlank()) return
            field = value
            isNeedCalculated = true
            invalidate()
        }
    var ellipsizeTextWidth = getTextWidth(ellipsizedText)
    var isRemeasured = false
    var isNeedCalculated = true
    lateinit var expandedStaticLayout: StaticLayout
    lateinit var collapsedStaticLayout: StaticLayout

    fun onClick() {
        if (!isSingleLine) {
            isExpanding = !isExpanding
            isRemeasured = false
            invalidate()
        }
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        setMeasuredDimension(widthMeasureSpec, contentHeight)
    }

    fun getStaticLayout(text: String, boundWidth: Int) =
        StaticLayout.Builder.obtain(text, 0, text.length, textPaint, boundWidth)
            .setAlignment(Layout.Alignment.ALIGN_NORMAL)
            .setLineSpacing(0f, 1f)
            .setIncludePad(false)
            .build()

    fun getCollapsedStaticLayoutWidth(collapsedString: String, layoutWidth: Int): Int {
        var staticLayout: StaticLayout
        var additionalWidth = 0
        while (getStaticLayout(collapsedString, layoutWidth + additionalWidth).run {
                staticLayout = this
                this.lineCount > 1
            }) {
            additionalWidth++
        }
        return staticLayout.width + additionalWidth
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        if (isNeedCalculated) {
            expandedStaticLayout = getStaticLayout(text, canvas.width)
            if (expandedStaticLayout.lineCount <= 1) {
                isSingleLine = true
                isExpanding = true
            } else {
                val ellipsizedPosition = getTextPositionToEllipsize(canvas.width)
                val collapsedString = text.substring(0, ellipsizedPosition) + ellipsizedText
                collapsedStaticLayout = getStaticLayout(
                    collapsedString,
                    getCollapsedStaticLayoutWidth(collapsedString, canvas.width)
                )
                isSingleLine = false
                isExpanding = false
            }
            isNeedCalculated = false
        }
        if (isExpanding) {
            contentHeight = expandedStaticLayout.height
            expandedStaticLayout.draw(canvas)
        } else {
            contentHeight = collapsedStaticLayout.height
            collapsedStaticLayout.draw(canvas)
        }
        isRemeasured = if (isRemeasured) {
            false
        } else {
            requestLayout()
            true
        }
    }

    private fun getTextWidth(text: String): Int {
        val contentBound = Rect()
        textPaint.getTextBounds(text, 0, text.length, contentBound)
        return contentBound.width()
    }

    fun getTextPositionToEllipsize(layoutWidth: Int): Int {
        if (text.isEmpty()) return 0
        var subString = ""
        var subStringEndPosition = 0
        while (getTextWidth(subString) + ellipsizeTextWidth < layoutWidth) {
            val endPosition = ++subStringEndPosition
            if (endPosition > text.length) break
            subString = text.substring(0, endPosition)
        }
        return subStringEndPosition - 2
    }
}
